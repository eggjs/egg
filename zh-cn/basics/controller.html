<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <title>controller - 为企业级框架和应用而生</title>
<meta charset="utf-8">
<meta name="description" content="为企业级框架和应用而生">
<meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<link rel="icon" href="/images/favicon.png" type="image/x-icon">
<link rel="stylesheet" href="/css/index.css">

</head>
<body>
  <div id="container">
    <div class="nav">
  <header>
    <a href="/zh-cn/" class="nav-logo" alt="egg"><img src="/images/logo.svg"></a>
    <ul>
      <li><a href="/zh-cn/intro/" alt="新手指南">新手指南</a></li><li><a href="https://eggjs.org/badgeboard/" alt="插件">插件</a></li><li><a href="/release/" alt="发布记录">发布记录</a></li>
      <li><iframe src="https://ghbtns.com/github-btn.html?user=eggjs&repo=egg&type=star&count=false" frameborder="0" scrolling="0" width="54px" height="20px"></iframe></li>
    </ul>
  </header>
</div>

    <div class="page-title">
  <h1>GUIDE</h1>
  <h2>The best way to know egg</h2>
</div>

<div class="page-main">
  <article class="markdown-body">
    <h1>controller</h1>
    <h2 id="什么是-controller"><a class="markdown-anchor" href="#什么是-controller">#</a> 什么是 controller</h2>
<p><a href="./router.html">前面章节</a>写到，我们通过 router 将用户的请求基于 method 和 URL 分发到了对应的 controller 上，那 controller 负责做什么？</p>
<p>简单的说 controller 负责<strong>解析用户的输入，处理后返回相应的结果</strong>，例如</p>
<ul>
<li>在 <a href="https://en.wikipedia.org/wiki/Representational_state_transfer" target="_blank" rel="external">RESTful</a> 接口中，controller 接受用户的参数，从数据库中查找内容返回给用户或者将用户的请求更新到数据库中。</li>
<li>在 html 页面请求中，controller 根据用户访问不同的 URL，渲染不同的模板得到 html 返回给用户。</li>
<li>在代理服务器中，controller 将用户的请求转发到其他服务器上，并将其他服务器的处理结果返回给用户。</li>
</ul>
<p>框架推荐 controller 层主要对用户的请求参数进行处理（校验、转换），然后调用对应的 <a href="./service.html">service</a> 方法处理业务，得到业务结果后封装并返回：</p>
<ol>
<li>获取用户通过 HTTP 传递过来的请求参数。</li>
<li>校验、组装参数。</li>
<li>调用 service 进行业务处理，必要时处理转换 service 的返回结果，让它适应用户的需求。</li>
<li>通过 HTTP 将结果响应给用户。</li>
</ol>
<h2 id="如何编写-controller"><a class="markdown-anchor" href="#如何编写-controller">#</a> 如何编写 controller</h2>
<p>所有的 controller 都必须放在 <code>app/controller</code> 目录下，每一个 controller 都是一个 generator function，它的 <code>this</code> 都被绑定成了 <a href="./extend.html#context">Context</a> 对象的实例，通过它我们可以拿到框架封装好的各种便捷属性和方法。</p>
<p>例如我们写一个对应到 <code>POST /api/posts</code> 接口的 controller，我们会在 <code>app/controller</code> 目录下创建一个 <code>post.js</code> 文件</p>
<p><figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="comment">// app/controller/post.js</span></div><div class="line"><span class="keyword">const</span> createRule = &#123;</div><div class="line">  <span class="attr">title</span>: &#123; <span class="attr">type</span>: <span class="string">'string'</span> &#125;,</div><div class="line">  <span class="attr">content</span>: &#123; <span class="attr">type</span>: <span class="string">'string'</span> &#125;,</div><div class="line">&#125;;</div><div class="line">exports.create = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="comment">// 校验参数</span></div><div class="line">  <span class="keyword">this</span>.validate(createRule);</div><div class="line">  <span class="comment">// 组装参数</span></div><div class="line">  <span class="keyword">const</span> author = <span class="keyword">this</span>.session.userId;</div><div class="line">  <span class="keyword">const</span> req = <span class="built_in">Object</span>.assign(<span class="keyword">this</span>.request.body, &#123; author &#125;);</div><div class="line">  <span class="comment">// 调用 service 进行业务处理</span></div><div class="line">  <span class="keyword">const</span> res = <span class="keyword">yield</span> <span class="keyword">this</span>.service.post.create(req);</div><div class="line">  <span class="comment">// 设置响应内容和响应状态码</span></div><div class="line">  <span class="keyword">this</span>.body = &#123; <span class="attr">id</span>: res.id &#125;;</div><div class="line">  <span class="keyword">this</span>.status = <span class="number">201</span>;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>在上面的例子中我们引入了许多新的概念，但还是比较直观，容易理解的，我们会在下面对它们进行更详细的介绍。</p>
<h2 id="http-基础"><a class="markdown-anchor" href="#http-基础">#</a> HTTP 基础</h2>
<p>由于 controller 基本上是业务开发中唯一和 HTTP 协议打交道的地方，在继续往下了解之前，我们首先简单的看一下 HTTP 协议是怎样的。</p>
<p>如果我们发起一个 HTTP 请求来访问前面例子中提到的 controller：</p>
<p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">curl -X POST http://localhost:3000/api/posts --data &apos;&#123;&quot;title&quot;:&quot;controller&quot;, &quot;content&quot;: &quot;what is controller&quot;&#125;&apos; --header &apos;Content-Type:application/json; charset=UTF-8&apos;</div></pre></td></tr></table></figure></p>
<p>通过 curl 发出的 HTTP 请求的内容就会是下面这样的：</p>
<p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">POST /api/posts HTTP/1.1</div><div class="line">Host: localhost:3000</div><div class="line">Content-Type: application/json; charset=UTF-8</div><div class="line"></div><div class="line">&#123;&quot;title&quot;: &quot;controller&quot;, &quot;content&quot;: &quot;what is controller&quot;&#125;</div></pre></td></tr></table></figure></p>
<p>请求的第一行包含了三个信息，我们比较常用的是前面两个：</p>
<ul>
<li>method：这个请求中 method 的值是 <code>POST</code>。</li>
<li>path：值为 <code>/api/posts</code>，如果用户的请求中包含 query，也会在这里出现</li>
</ul>
<p>从第二行开始直到遇到的第一个空行位置，都是请求的 headers 部分，这一部分中有许多常用的属性，包括这里看到的 Host，Content-Type，还有 <code>Cookie</code>，<code>User-Agent</code> 等等。在这个请求中有两个头：</p>
<ul>
<li><code>Host</code>：我们在浏览器发起请求的时候，域名会用来通过 DNS 解析找到服务的 ip 地址，但是浏览器也会将域名和端口号放在 Host 头中一并发送给服务端。</li>
<li><code>Content-Type</code>：当我们的请求有 body 的时候，都会有 Content-Type 来标明我们的请求体是什么格式的。</li>
</ul>
<p>之后的内容全部都是请求的 body，当请求是 POST, PUT, DELETE 等方法的时候，可以带上请求体，服务端会根据 Content-Type 来解析请求体。</p>
<p>在服务端处理完这个请求后，会发送一个 HTTP 响应给客户端</p>
<p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">HTTP/1.1 201 Created</div><div class="line">Content-Type: application/json; charset=utf-8</div><div class="line">Content-Length: 8</div><div class="line">Date: Mon, 09 Jan 2017 08:40:28 GMT</div><div class="line">Connection: keep-alive</div><div class="line"></div><div class="line">&#123;&quot;id&quot;: 1&#125;</div></pre></td></tr></table></figure></p>
<p>第一行中也包含了三段，其中我们常用的主要是<a href="https://en.wikipedia.org/wiki/List_of_HTTP_status_codes" target="_blank" rel="external">响应状态码</a>，这个例子中它的值是 201，它的含义是在服务端成功创建了一条资源。</p>
<p>和请求一样，从第二行开始到下一个空行之间都是响应头，这里的 Content-Type, Content-Length 表示这个响应的格式是 json，长度为 8 个字符。</p>
<p>最后剩下的部分就是这次响应真正的内容。</p>
<h2 id="获取-http-请求参数"><a class="markdown-anchor" href="#获取-http-请求参数">#</a> 获取 HTTP 请求参数</h2>
<p>从上面的 HTTP 请求示例中可以看到，有好多地方可以放用户的请求数据，框架通过在 controller 上绑定的 context 实例，提供了许多便捷方法和属性获取用户通过 HTTP 请求发送过来的参数。</p>
<h3 id="query"><a class="markdown-anchor" href="#query">#</a> query</h3>
<p>在 URL 中 <code>?</code> 后面的部分是一个 query string，这一部分经常用于 GET 类型的请求中传递参数。例如 <code>GET /posts?category=egg&amp;language=node</code> 中 <code>category=egg&amp;language=node</code> 就是用户传递过来的参数。我们可以通过 <code>context.query</code> 拿到解析过后的这个参数体</p>
<p><figure class="highlight js"><table><tr><td class="code"><pre><div class="line">exports.listPosts = <span class="function"><span class="keyword">function</span>*(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">const</span> query = <span class="keyword">this</span>.query;</div><div class="line">  <span class="comment">// &#123;</span></div><div class="line">  <span class="comment">//   category: 'egg',</span></div><div class="line">  <span class="comment">//   language: 'node',</span></div><div class="line">  <span class="comment">// &#125;</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>当 query string 中的 key 重复时，<code>context.query</code> 只取 key 第一次出现时的值，后面再出现的都会被忽略。<code>GET /posts?category=egg&amp;category=koa</code> 通过 <code>context.query</code> 拿到的值是 <code>{ category: 'egg' }</code>。</p>
<p>这样处理的原因是为了保持统一性，由于通常情况下我们都不会设计让用户传递 key 相同的 query string，所以我们经常会写类似下面的代码：</p>
<p><figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="keyword">const</span> key = <span class="keyword">this</span>.query.key || <span class="string">''</span>;</div><div class="line"><span class="keyword">if</span> (key.startsWith(<span class="string">'egg'</span>)) &#123;</div><div class="line">  <span class="comment">// do something</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>而如果有人故意发起请求在 query string 中带上重复的 key 来请求时就会引发系统异常。因此框架保证了从 <code>context.query</code> 上获取的参数一旦存在，一定是字符串类型。</p>
<h4 id="queries"><a class="markdown-anchor" href="#queries">#</a> queries</h4>
<p>有时候我们的系统会设计成让用户传递相同的 key，例如 <code>GET /posts?category=egg&amp;id=1&amp;id=2&amp;id=3</code>。针对此类情况，框架提供了 <code>context.queries</code> 对象，这个对象也解析了 query string，但是它不会丢弃任何一个重复的数据，而是将他们都放到一个数组中：</p>
<p><figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="comment">// GET /posts?category=egg&amp;id=1&amp;id=2&amp;id=3</span></div><div class="line"></div><div class="line">exports.listPosts = <span class="function"><span class="keyword">function</span>*(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.queries);</div><div class="line">  <span class="comment">// &#123;</span></div><div class="line">  <span class="comment">//   category: [ 'egg' ],</span></div><div class="line">  <span class="comment">//   id: [ '1', '2', '3' ],</span></div><div class="line">  <span class="comment">// &#125;</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p><code>context.queries</code> 上所有的 key 如果有值，也一定会是数组类型。</p>
<h3 id="router-params"><a class="markdown-anchor" href="#router-params">#</a> router params</h3>
<p>在 <a href="./router.html">router</a> 中，我们介绍了 router 上也可以申明参数，这些参数都可以通过 <code>context.params</code> 获取到。</p>
<p><figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="comment">// app.get('/projects/:projectId/app/:appId', 'app.listApp');</span></div><div class="line"><span class="comment">// GET /projects/1/app/2</span></div><div class="line"></div><div class="line">exports.listApp = <span class="function"><span class="keyword">function</span>*(<span class="params"></span>) </span>&#123;</div><div class="line">  assert.equal(<span class="keyword">this</span>.params.projectId, <span class="string">'1'</span>);</div><div class="line">  assert.equal(<span class="keyword">this</span>.params.appId, <span class="string">'2'</span>);</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h3 id="body"><a class="markdown-anchor" href="#body">#</a> body</h3>
<p>虽然我们可以通过 URL 传递参数，但是还是有诸多限制：</p>
<ul>
<li><a href="http://stackoverflow.com/questions/417142/what-is-the-maximum-length-of-a-url-in-different-browsers" target="_blank" rel="external">浏览器中会对 URL 的长度有所限制</a>，如果需要传递的参数过多就会无法传递。</li>
<li>服务端经常会将访问的完整 URL 记录到日志文件中，有一些敏感数据通过 URL 传递会不安全。</li>
</ul>
<p>在前面的 HTTP 请求报文示例中，我们看到在 header 之后还有一个 body 部分，我们通常会在这个部分传递 POST、PUT 和 DELETE 等方法的参数。一般请求中有 body 的时候，客户端（浏览器）会同时发送 <code>Content-Type</code> 告诉服务端这次请求的 body 是什么格式的。web 开发中数据传递最常用的两类格式分别是 json 和 form。</p>
<p>框架内置了 <a href="https://github.com/koajs/bodyparser" target="_blank" rel="external">bodyParser</a> 中间件来对这两类格式的请求 body 解析成 object 挂载到 <code>context.request.body</code> 上。HTTP 协议中并不建议在通过 GET、HEAD 方法访问时传递 body，所以我们无法在 GET、HEAD 方法中按照此方法获取到内容。</p>
<p><figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="comment">// POST /api/posts HTTP/1.1</span></div><div class="line"><span class="comment">// Host: localhost:3000</span></div><div class="line"><span class="comment">// Content-Type: application/json; charset=UTF-8</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// &#123;"title": "controller", "content": "what is controller"&#125;</span></div><div class="line">exports.listPosts = <span class="function"><span class="keyword">function</span>*(<span class="params"></span>) </span>&#123;</div><div class="line">  assert.equal(<span class="keyword">this</span>.request.body.title, <span class="string">'controller'</span>);</div><div class="line">  assert.equal(<span class="keyword">this</span>.request.body.content, <span class="string">'what is controller'</span>);</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>框架对 bodyParser 设置了一些默认参数，配置好之后拥有以下特性：</p>
<ul>
<li>当请求的 Content-Type 为 <code>application/json</code>，<code>application/json-patch+json</code>，<code>application/vnd.api+json</code> 和 <code>application/csp-report</code> 时，会按照 json 格式对请求 body 进行解析，并限制 body 最大长度为 <code>100kb</code>。</li>
<li>当请求的 Content-Type 为 <code>application/x-www-form-urlencoded</code> 时，会按照 form 格式对请求 body 进行解析，并限制 body 最大长度为 <code>100kb</code>。</li>
<li>如果解析成功，body 一定会是一个 Object（可能是一个数组）。</li>
</ul>
<p>一般来说我们最经常调整的配置项就是变更解析时允许的最大长度，可以在 <code>config/config.default.js</code> 中覆盖框架的默认值</p>
<p><figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="built_in">module</span>.exports = &#123;</div><div class="line">  <span class="attr">bodyParser</span>: &#123;</div><div class="line">    <span class="attr">jsonLimit</span>: <span class="string">'1m'</span>,</div><div class="line">    <span class="attr">formLimit</span>: <span class="string">'1m'</span>,</div><div class="line">  &#125;,</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>如果用户的请求 body 超过了我们配置的解析最大长度，会抛出一个状态码为 <code>413</code> 的异常，如果用户请求的 body 解析失败（错误的 JSON），会抛出一个状态码为 <code>400</code> 的异常。</p>
<p><strong>注意：在调整 bodyParser 支持的 body 长度时，如果我们应用前面还有一层反向代理（nginx），可能也需要调整它的配置，确保反向代理也支持同样长度的请求 body。</strong></p>
<h3 id="获取上传的文件"><a class="markdown-anchor" href="#获取上传的文件">#</a> 获取上传的文件</h3>
<p>请求 body 除了可以带参数之外，还可以发送文件，一般来说，浏览器上都是通过 <code>Multipart/form-data</code> 格式发送文件的，框架通过内置 <a href="https://github.com/eggjs/egg-multipart" target="_blank" rel="external">multipart</a> 插件来支持获取用户上传的文件。</p>
<p>在 controller 中，我们可以通过 <code>context.getFileStream*()</code> 接口能获取到上传的文件流。</p>
<p><figure class="highlight html"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">method</span>=<span class="string">"POST"</span> <span class="attr">action</span>=<span class="string">"/upload?_csrf=&#123;&#123; ctx.csrf | safe &#125;&#125;"</span> <span class="attr">enctype</span>=<span class="string">"multipart/form-data"</span>&gt;</span></div><div class="line">  title: <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">"title"</span> /&gt;</span></div><div class="line">  file: <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">"file"</span> <span class="attr">type</span>=<span class="string">"file"</span> /&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"submit"</span>&gt;</span>上传<span class="tag">&lt;/<span class="name">button</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p><figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</div><div class="line"><span class="keyword">const</span> sendToWormhole = <span class="built_in">require</span>(<span class="string">'stream-wormhole'</span>);</div><div class="line"></div><div class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>*(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">const</span> stream = <span class="keyword">yield</span> <span class="keyword">this</span>.getFileStream();</div><div class="line">  <span class="keyword">const</span> name = <span class="string">'egg-multipart-test/'</span> + path.basename(stream.filename);</div><div class="line">  <span class="comment">// 文件处理，上传到云存储等等</span></div><div class="line">  <span class="keyword">let</span> result;</div><div class="line">  <span class="keyword">try</span> &#123;</div><div class="line">    result = <span class="keyword">yield</span> <span class="keyword">this</span>.oss.put(name, stream);</div><div class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</div><div class="line">    <span class="comment">// 必须将上传的文件流消费掉，要不然浏览器响应会卡死</span></div><div class="line">    <span class="keyword">yield</span> sendToWormhole(stream);</div><div class="line">    <span class="keyword">throw</span> err;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">this</span>.body = &#123;</div><div class="line">    <span class="attr">url</span>: result.url,</div><div class="line">    <span class="comment">// 所有表单字段都能通过 `stream.fields` 获取到</span></div><div class="line">    fields: stream.fields,</div><div class="line">  &#125;;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>要通过 <code>context.getFileStream</code> 便捷的获取到用户上传的文件，需要满足两个条件：</p>
<ul>
<li>上传文件必须在其他 field 之前。</li>
<li>只支持上传一个文件。</li>
</ul>
<p>如果要获取同时上传的多个文件，不能通过 <code>this.getFileStream()</code> 来获取，只能通过下面这种方式：</p>
<p><figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="keyword">const</span> sendToWormhole = <span class="built_in">require</span>(<span class="string">'stream-wormhole'</span>);</div><div class="line"></div><div class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>*(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">const</span> parts = <span class="keyword">this</span>.multipart();</div><div class="line">  <span class="keyword">let</span> part;</div><div class="line">  <span class="keyword">while</span> ((part = <span class="keyword">yield</span> parts) != <span class="literal">null</span>) &#123;</div><div class="line">    <span class="keyword">if</span> (part.length) &#123;</div><div class="line">      <span class="comment">// 如果是数组的话是 filed</span></div><div class="line">      <span class="built_in">console</span>.log(<span class="string">'field: '</span> + part[<span class="number">0</span>]);</div><div class="line">      <span class="built_in">console</span>.log(<span class="string">'value: '</span> + part[<span class="number">1</span>]);</div><div class="line">      <span class="built_in">console</span>.log(<span class="string">'valueTruncated: '</span> + part[<span class="number">2</span>]);</div><div class="line">      <span class="built_in">console</span>.log(<span class="string">'fieldnameTruncated: '</span> + part[<span class="number">3</span>]);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      <span class="keyword">if</span> (!part.filename) &#123;</div><div class="line">        <span class="comment">// 这时是用户没有选择文件就点击了上传(part 是 file stream，但是 part.filename 为空)</span></div><div class="line">        <span class="comment">// 需要做出处理，例如给出错误提示消息</span></div><div class="line">        <span class="keyword">return</span>;</div><div class="line">      &#125;</div><div class="line">      <span class="comment">// part 是上传的文件流</span></div><div class="line">      <span class="built_in">console</span>.log(<span class="string">'field: '</span> + part.fieldname);</div><div class="line">      <span class="built_in">console</span>.log(<span class="string">'filename: '</span> + part.filename);</div><div class="line">      <span class="built_in">console</span>.log(<span class="string">'encoding: '</span> + part.encoding);</div><div class="line">      <span class="built_in">console</span>.log(<span class="string">'mime: '</span> + part.mime);</div><div class="line">      <span class="comment">// 文件处理，上传到云存储等等</span></div><div class="line">      <span class="keyword">let</span> result;</div><div class="line">      <span class="keyword">try</span> &#123;</div><div class="line">        result = <span class="keyword">yield</span> <span class="keyword">this</span>.oss.put(<span class="string">'egg-multipart-test/'</span> + part.filename, part);</div><div class="line">      &#125; <span class="keyword">catch</span> (err) &#123;</div><div class="line">        <span class="comment">// 必须将上传的文件流消费掉，要不然浏览器响应会卡死</span></div><div class="line">        <span class="keyword">yield</span> sendToWormhole(stream);</div><div class="line">        <span class="keyword">throw</span> err;</div><div class="line">      &#125;</div><div class="line">      <span class="built_in">console</span>.log(result);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'and we are done parsing the form!'</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>为了保证文件上传的安全，框架限制了支持的的文件格式，框架默认支持白名单如下：</p>
<p><figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="comment">// images</span></div><div class="line"><span class="string">'.jpg'</span>, <span class="string">'.jpeg'</span>, <span class="comment">// image/jpeg</span></div><div class="line"><span class="string">'.png'</span>, <span class="comment">// image/png, image/x-png</span></div><div class="line"><span class="string">'.gif'</span>, <span class="comment">// image/gif</span></div><div class="line"><span class="string">'.bmp'</span>, <span class="comment">// image/bmp</span></div><div class="line"><span class="string">'.wbmp'</span>, <span class="comment">// image/vnd.wap.wbmp</span></div><div class="line"><span class="string">'.webp'</span>,</div><div class="line"><span class="string">'.tif'</span>,</div><div class="line"><span class="string">'.psd'</span>,</div><div class="line"><span class="comment">// text</span></div><div class="line"><span class="string">'.svg'</span>,</div><div class="line"><span class="string">'.js'</span>, <span class="string">'.jsx'</span>,</div><div class="line"><span class="string">'.json'</span>,</div><div class="line"><span class="string">'.css'</span>, <span class="string">'.less'</span>,</div><div class="line"><span class="string">'.html'</span>, <span class="string">'.htm'</span>,</div><div class="line"><span class="string">'.xml'</span>,</div><div class="line"><span class="comment">// tar</span></div><div class="line"><span class="string">'.zip'</span>,</div><div class="line"><span class="string">'.gz'</span>, <span class="string">'.tgz'</span>, <span class="string">'.gzip'</span>,</div><div class="line"><span class="comment">// video</span></div><div class="line"><span class="string">'.mp3'</span>,</div><div class="line"><span class="string">'.mp4'</span>,</div><div class="line"><span class="string">'.avi'</span>,</div></pre></td></tr></table></figure></p>
<p>用户可以通过在 <code>config/config.default.js</code> 中配置来新增支持的文件扩展名，或者重写整个白名单</p>
<ul>
<li>新增支持的文件扩展名</li>
</ul>
<p><figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="built_in">module</span>.exports = &#123;</div><div class="line">  <span class="attr">multipart</span>: &#123;</div><div class="line">    <span class="attr">fileExtensions</span>: [ <span class="string">'.apk'</span> ], <span class="comment">// 增加对 .apk 扩展名的支持</span></div><div class="line">  &#125;,</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<ul>
<li>覆盖整个白名单</li>
</ul>
<p><figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="built_in">module</span>.exports = &#123;</div><div class="line">  <span class="attr">multipart</span>: &#123;</div><div class="line">    <span class="attr">whitelist</span>: [ <span class="string">'.png'</span> ], <span class="comment">// 覆盖整个白名单，只允许上传 '.png' 格式</span></div><div class="line">  &#125;,</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p><strong>注意：当传递了 whitelist 属性时，fileExtensions 属性不生效。</strong></p>
<h3 id="header"><a class="markdown-anchor" href="#header">#</a> header</h3>
<p>除了从 URL 和请求 body 上获取参数之外，还有许多参数是通过请求 header 传递的。框架提供了一些辅助属性和方法来获取。</p>
<ul>
<li><code>context.headers</code>，<code>context.header</code>，<code>context.request.headers</code>，<code>context.request.header</code>：这几个方法是等价的，都是获取整个 header 对象。</li>
<li><code>context.get(name)</code>，<code>context.request.get(name)</code>：获取请求 header 中的一个字段的值，如果这个字段不存在，会返回空字符串。</li>
<li>我们建议用 <code>context.get(name)</code> 而不是 <code>context.headers['name']</code>，因为前者会自动处理大小写。</li>
</ul>
<p>由于 header 比较特殊，有一些是 <code>HTTP</code> 协议规定了具体含义的（例如 <code>Content-Type</code>，<code>Accept</code>），有些是反向代理设置的，已经约定俗成（X-Forwarded-For），框架也会对他们增加一些便捷的 getter，详细的 getter 可以查看 <a href="https://eggjs.org/api/">API</a> 文档。</p>
<p>特别是如果我们通过 <code>config.proxy = true</code> 设置了应用部署在反向代理（nginx）之后，有一些 getter 的内部处理会发生改变。</p>
<h4 id="contexthost"><a class="markdown-anchor" href="#contexthost">#</a> <code>context.host</code></h4>
<p>优先读通过 <code>config.hostHeaders</code> 中配置的 header 的值，读不到时再尝试获取 host 这个 header 的值，如果都获取不到，返回空字符串。</p>
<p><code>config.hostHeaders</code> 默认配置为 <code>x-forwarded-host</code>。</p>
<h4 id="contextprotocol"><a class="markdown-anchor" href="#contextprotocol">#</a> <code>context.protocol</code></h4>
<p>通过这个 getter 获取 protocol 时，首先会判断当前连接是否是加密连接，如果是加密连接，返回 https。</p>
<p>如果处于非加密连接时，优先读通过 <code>config.protocolHeaders</code> 中配置的 header 的值来判断是 http 还是 https，如果读取不到，我们可以在配置中通过 <code>config.protocol</code> 来设置兜底值，默认为 http。</p>
<p><code>config.protocolHeaders</code> 默认配置为 <code>x-forwarded-proto</code>。</p>
<h4 id="contextips"><a class="markdown-anchor" href="#contextips">#</a> <code>context.ips</code></h4>
<p>通过 <code>context.ips</code> 获取请求经过所有的中间设备 ip 地址列表，只有在 <code>config.proxy = true</code> 时，才会通过读取 <code>config.ipHeaders</code> 中配置的 header 的值来获取，获取不到时为空数组。</p>
<p><code>config.ipHeaders</code> 默认配置为 <code>x-forwarded-for</code>。</p>
<h4 id="contextip"><a class="markdown-anchor" href="#contextip">#</a> <code>context.ip</code></h4>
<p>通过 <code>context.ip</code> 获取请求发起方的 ip 地址，优先从 <code>context.ips</code> 中获取，<code>context.ips</code> 为空时使用连接上发起方的 ip 地址。</p>
<p><strong>注意：ip 和 ips 不同，ip 当 <code>config.proxy = false</code> 时会返回当前连接发起者的 ip 地址，ips 此时会为空数组。</strong></p>
<h3 id="cookie"><a class="markdown-anchor" href="#cookie">#</a> cookie</h3>
<p>HTTP 的请求头中有一个特殊的字段叫 <a href="https://en.wikipedia.org/wiki/HTTP_cookie" target="_blank" rel="external">cookie</a>。服务端可以通过 cookie 将少量数据存到客户端中（浏览器会遵循协议将数据保存）。HTTP 请求都是无状态的，但是我们的 web 应用通常都需要知道发起请求的人是谁，一个常用的解决方案就是通过 cookie 来确认用户身份。</p>
<p>通过 <code>context.cookies</code>，我们可以在 controller 中便捷、安全的设置和读取 cookie。</p>
<p><figure class="highlight js"><table><tr><td class="code"><pre><div class="line">exports.add = <span class="function"><span class="keyword">function</span>*(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">const</span> count = <span class="keyword">this</span>.cookie.get(<span class="string">'count'</span>);</div><div class="line">  count = count ? <span class="built_in">Number</span>(count) : <span class="number">0</span>;</div><div class="line">  <span class="keyword">this</span>.cookie.set(<span class="string">'count'</span>, ++count);</div><div class="line">  <span class="keyword">this</span>.body = count;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">exports.remove = <span class="function"><span class="keyword">function</span>*(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">const</span> count = <span class="keyword">this</span>.cookie.set(<span class="string">'count'</span>, <span class="literal">null</span>);</div><div class="line">  <span class="keyword">this</span>.status = <span class="number">204</span>;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>cookie 虽然在 HTTP 中只是一个头，但是通过 <code>foo=bar;foo1=bar1;</code> 的格式可以设置多个键值对。</p>
<h4 id="contextcookiessetkey-value-options"><a class="markdown-anchor" href="#contextcookiessetkey-value-options">#</a> <code>context.cookies.set(key, value, options)</code></h4>
<p>设置 cookie 其实是通过在 HTTP 响应中设置 set-cookie 头完成的，每一个 set-cookie 都会让浏览器在 cookie 中存一个键值对。在设置 cookie 值的同时，协议还支持许多参数来配置这个 cookie 的传输、存储和权限。</p>
<ul>
<li>maxAge (Number): 设置这个键值对在浏览器的最长保存时间。是一个从服务器当前时刻开始的毫秒数。</li>
<li>expires (Date): 设置这个键值对的失效时间，如果设置了 maxAge，将会被覆盖。如果 maxAge 和 expires 都没设置，cookie 将会在浏览器的会话失效（一般是关闭浏览器时）的时候失效。</li>
<li>path (String): 设置键值对生效的路径，默认设置在根路径上（<code>/</code>）。</li>
<li>domain (String): 设置键值对生效的域名，默认没有配置。</li>
<li>httpOnly (Boolean): 设置键值对是否不能被 js 访问，默认为 true，不允许被 js 访问。</li>
<li>secure (Boolean): 设置键值对<a href="http://stackoverflow.com/questions/13729749/how-does-cookie-secure-flag-work" target="_blank" rel="external">只在 HTTPS 连接上传输</a>，框架会帮我们判断当前是否在 HTTPS 连接上自动设置 secure 的值。</li>
</ul>
<p>除了这些属性之外，框架另外扩展了 3 个参数的支持：</p>
<ul>
<li>overwrite(Boolean)：设置 key 相同的键值对如何处理，如果设置为 true，则后设置的值会覆盖前面设置的，否则将会发送两个 set-cookie 响应头。</li>
<li>sign（Boolean）：设置是否对 cookie 进行签名，如果设置为 true，则设置键值对的时候会同时对这个键值对的值进行签名，后面取的时候做校验，可以防止前端对这个值进行篡改。默认为 true。</li>
<li>encrypt（Boolean）：设置是否对 cookie 进行加密，如果设置为 true，则在发送 cookie 前会对这个键值对的值进行加密，客户端无法读取到 cookie 的值。默认为 false。</li>
</ul>
<p>在设置 cookie 时我们需要思考清楚这个 cookie 的作用，它需要被浏览器保存多久？是否可以被 js 获取到？是否可以被前端修改？</p>
<p><strong>默认的配置下，cookie 是加签不加密的，浏览器可以看到明文，js 不能访问，不能被客户端（手工）篡改。</strong></p>
<ul>
<li>如果想要 cookie 在浏览器端可以被 js 访问并修改:</li>
</ul>
<p><figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="keyword">this</span>.cookies.set(key, value, &#123;</div><div class="line">  <span class="attr">httpOnly</span>: <span class="literal">false</span>,</div><div class="line">  <span class="attr">sign</span>: <span class="literal">false</span>,</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<ul>
<li>如果想要 cookie 在浏览器端不能被修改，不能看到明文：</li>
</ul>
<p><figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="keyword">this</span>.cookies.set(key, value, &#123;</div><div class="line">  <span class="attr">httpOnly</span>: <span class="literal">true</span>, <span class="comment">// 默认就是 true</span></div><div class="line">  encrypt: <span class="literal">true</span>, <span class="comment">// 加密传输</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>注意：</p>
<ol>
<li>由于<a href="http://stackoverflow.com/questions/7567154/can-i-use-unicode-characters-in-http-headers" target="_blank" rel="external">浏览器和其他客户端实现的不确定性</a>，为了保证 cookie 可以写入成功，建议 value 通过 base64 编码或者其他形式 encode 之后再写入。</li>
<li>由于<a href="http://stackoverflow.com/questions/640938/what-is-the-maximum-size-of-a-web-browsers-cookies-key" target="_blank" rel="external">浏览器对 cookie 有长度限制限制</a>，所以尽量不要设置太长的 cookie。一般来说不要超过 4000 bytes。</li>
</ol>
<h4 id="contextcookiesgetkey-options"><a class="markdown-anchor" href="#contextcookiesgetkey-options">#</a> <code>context.cookies.get(key, options)</code></h4>
<p>由于 HTTP 请求中的 cookie 是在一个 header 中传输过来的，通过框架提供的这个方法可以快速的从整段 cookie 中获取对应的键值对的值。上面在设置 cookie 的时候，我们可以设置 <code>options.signed</code> 和 <code>options.encrypt</code> 来对 cookie 进行签名或加密，因此对应的在获取 cookie 的时候也要传相匹配的选项。</p>
<ul>
<li>如果设置的时候指定为 signed，获取时未指定，则不会在获取时对取到的值做验签，导致可能被客户端篡改。</li>
<li>如果设置的时候指定为 encrypt，获取时未指定，则无法获取到真实的值，而是加密过后的密文。</li>
</ul>
<h3 id="cookie-秘钥"><a class="markdown-anchor" href="#cookie-秘钥">#</a> cookie 秘钥</h3>
<p>由于我们在 cookie 中需要用到加解密和验签，所以需要配置一个秘钥供加密使用。在 <code>config/config.default.js</code> 中</p>
<p><figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="built_in">module</span>.exports = &#123;</div><div class="line">  <span class="attr">keys</span>: <span class="string">'key1,key2'</span>,</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>keys 配置成一个字符串，可以按照逗号分隔配置多个 key。cookie 在使用这个配置进行加解密时：</p>
<ul>
<li>加密时只会使用第一个秘钥。</li>
<li>解密或验签时会遍历 keys 进行解密。</li>
</ul>
<p>如果我们想要更新 cookie 的秘钥，但是又不希望之前设置到用户浏览器上的 cookie 失效，可以将新的秘钥配置到 keys 最前面，等过一段时间之后再删去不需要的秘钥即可。</p>
<h3 id="session"><a class="markdown-anchor" href="#session">#</a> session</h3>
<p>通过 cookie，我们可以给每一个用户设置一个 session，用来存储用户身份相关的信息，这份信息会加密后存储在 cookie 中，实现跨请求的用户身份保持。</p>
<p>框架内置了 <a href="https://github.com/eggjs/egg-session" target="_blank" rel="external">session</a> 插件，给我们提供了 <code>context.session</code> 来访问或者修改当前用户 session 。</p>
<p><figure class="highlight js"><table><tr><td class="code"><pre><div class="line">exports.fetchPosts = <span class="function"><span class="keyword">function</span>*(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="comment">// 获取 session 上的内容</span></div><div class="line">  <span class="keyword">const</span> userId = <span class="keyword">this</span>.session.userId;</div><div class="line">  <span class="keyword">const</span> posts = <span class="keyword">yield</span> <span class="keyword">this</span>.service.post.fetch(userId);</div><div class="line">  <span class="comment">// 修改 session 的值</span></div><div class="line">  <span class="keyword">this</span>.session.visited = <span class="keyword">this</span>.session.visited ? <span class="keyword">this</span>.session.visited++ : <span class="number">1</span>;</div><div class="line">  <span class="keyword">this</span>.body = &#123;</div><div class="line">    <span class="attr">success</span>: <span class="literal">true</span>,</div><div class="line">    posts,</div><div class="line">  &#125;;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>session 的使用方法非常直观，直接读取它或者修改它就可以了，如果要删除它，直接将它赋值为 null：</p>
<p><figure class="highlight js"><table><tr><td class="code"><pre><div class="line">exports.deleteSession = <span class="function"><span class="keyword">function</span>*(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.session = <span class="literal">null</span>;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h4 id="配置"><a class="markdown-anchor" href="#配置">#</a> 配置</h4>
<p>对于 session 来说，主要有下面几个属性可以在 <code>config.default.js</code> 中进行配置:</p>
<p><figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="built_in">module</span>.exports = &#123;</div><div class="line">  <span class="attr">key</span>: <span class="string">'EGG_SESS'</span>, <span class="comment">// 承载 session 的 cookie 键值对名字</span></div><div class="line">  maxAge: <span class="number">86400000</span>, <span class="comment">// session 的最大有效时间</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h2 id="参数校验"><a class="markdown-anchor" href="#参数校验">#</a> 参数校验</h2>
<p>在获取到用户请求的参数后，不可避免的要对参数进行一些校验，框架集成了 <a href="https://github.com/eggjs/egg-validate" target="_blank" rel="external">validate</a> 插件提供便捷的参数校验机制。</p>
<p>通过 <code>context.validate(rule, [body])</code> 直接对参数进行校验</p>
<p><figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="keyword">const</span> createRule = &#123;</div><div class="line">  <span class="attr">title</span>: &#123; <span class="attr">type</span>: <span class="string">'string'</span> &#125;,</div><div class="line">  <span class="attr">content</span>: &#123; <span class="attr">type</span>: <span class="string">'string'</span> &#125;,</div><div class="line">&#125;;</div><div class="line">exports.create = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="comment">// 校验参数</span></div><div class="line">  <span class="comment">// 如果不传第二个参数会自动校验 `this.request.body`</span></div><div class="line">  <span class="keyword">this</span>.validate(createRule);</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>当校验异常时，会直接抛出一个异常，异常的状态码为 422，errors 字段包含了详细的验证不通过信息。如果想要自己处理检查的异常，可以通过 <code>try catch</code> 来自行捕获。</p>
<p><figure class="highlight js"><table><tr><td class="code"><pre><div class="line">exports.create = <span class="function"><span class="keyword">function</span>*(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">try</span> &#123;</div><div class="line">    <span class="keyword">this</span>.validate(createRule);</div><div class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</div><div class="line">    <span class="keyword">this</span>.logger.warn(err.errors);</div><div class="line">    <span class="keyword">this</span>.body = &#123; <span class="attr">success</span>: <span class="literal">false</span> &#125;;</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h3 id="校验规则"><a class="markdown-anchor" href="#校验规则">#</a> 校验规则</h3>
<p>参数校验通过 <a href="https://github.com/node-modules/parameter#rule" target="_blank" rel="external">parameter</a> 完成，支持的校验规则可以在该模块的文档中查阅到。</p>
<h4 id="自定义校验规则"><a class="markdown-anchor" href="#自定义校验规则">#</a> 自定义校验规则</h4>
<p>除了上一节介绍的内置检验类型外，有时候我们希望自定义一些校验规则，让开发时更便捷，此时可以通过 <code>app.validator.addRule(type, check)</code> 的方式新增自定义规则。</p>
<p><figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="comment">// app.js</span></div><div class="line">app.validator.addRule(<span class="string">'json'</span>, (rule, value) =&gt; &#123;</div><div class="line">  <span class="keyword">try</span> &#123;</div><div class="line">    <span class="built_in">JSON</span>.parse(value);</div><div class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">'must be json string'</span>;</div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>添加完自定义规则之后，就可以在 controller 中直接使用这条规则来进行参数校验了</p>
<p><figure class="highlight js"><table><tr><td class="code"><pre><div class="line">exports.handler = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="comment">// query.test 字段必须是 json 字符串</span></div><div class="line">  <span class="keyword">const</span> rule = &#123; <span class="attr">test</span>: <span class="string">'json'</span> &#125;;</div><div class="line">  <span class="keyword">this</span>.validate(rule, <span class="keyword">this</span>.query);</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h2 id="调用-service"><a class="markdown-anchor" href="#调用-service">#</a> 调用 service</h2>
<p>我们并不想在 controller 中实现太多业务逻辑，所以提供了一个 <a href="./service.html">service</a> 层进行业务逻辑的封装，这不仅能提高代码的复用性，同时可以让我们的业务逻辑更好测试。</p>
<p>在 controller 中可以调用任何一个 service 上的任何方法，同时 service 是懒加载的，只有当访问到它的时候框架才会去实例化它。</p>
<p><figure class="highlight js"><table><tr><td class="code"><pre><div class="line">exports.create = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">const</span> author = <span class="keyword">this</span>.session.userId;</div><div class="line">  <span class="keyword">const</span> req = <span class="built_in">Object</span>.assign(<span class="keyword">this</span>.request.body, &#123; author &#125;);</div><div class="line">  <span class="comment">// 调用 service 进行业务处理</span></div><div class="line">  <span class="keyword">const</span> res = <span class="keyword">yield</span> <span class="keyword">this</span>.service.post.create(req);</div><div class="line">  <span class="keyword">this</span>.body = &#123; <span class="attr">id</span>: res.id &#125;;</div><div class="line">  <span class="keyword">this</span>.status = <span class="number">201</span>;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>service 的具体写法，请查看 <a href="./service.html">service</a> 章节。</p>
<h2 id="发送-http-响应"><a class="markdown-anchor" href="#发送-http-响应">#</a> 发送 HTTP 响应</h2>
<p>当业务逻辑完成之后，controller 的最后一个职责就是将业务逻辑的处理结果通过 HTTP 响应发送给用户。</p>
<h3 id="设置-status"><a class="markdown-anchor" href="#设置-status">#</a> 设置 status</h3>
<p>HTTP 设计了非常多的<a href="https://en.wikipedia.org/wiki/List_of_HTTP_status_codes" target="_blank" rel="external">状态码</a>，每一个状态码都代表了一个特定的含义，通过设置正确的状态码，可以让响应更符合语义。</p>
<p>框架提供了一个便捷的 setter 来进行状态码的设置</p>
<p><figure class="highlight js"><table><tr><td class="code"><pre><div class="line">exports.create = <span class="function"><span class="keyword">function</span>*(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="comment">// 设置状态码为 201</span></div><div class="line">  <span class="keyword">this</span>.status = <span class="number">201</span>;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>具体什么场景设置什么样的状态码，可以参考 <a href="https://en.wikipedia.org/wiki/List_of_HTTP_status_codes" target="_blank" rel="external">List of HTTP status codes</a> 中各个状态码的含义。</p>
<h3 id="设置-body"><a class="markdown-anchor" href="#设置-body">#</a> 设置 body</h3>
<p>绝大多数的数据都是通过 body 发送给请求方的，和请求中的 body 一样，在响应中发送的 body，也需要有配套的 Content-Type 告知客户端如何对数据进行解析。</p>
<ul>
<li>作为一个 RESTful 的 API 接口 controller，我们通常会返回 Content-Type 为 <code>application/json</code> 格式的 body，内容是一个 JSON 字符串。</li>
<li>作为一个 html 页面的 controller，我们通常会返回 Content-Type 为 <code>text/html</code> 格式的 body，内容是 html 代码段。</li>
</ul>
<p><figure class="highlight js"><table><tr><td class="code"><pre><div class="line">exports.show = <span class="function"><span class="keyword">function</span>*(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.body = &#123;</div><div class="line">    <span class="attr">name</span>: <span class="string">'egg'</span>,</div><div class="line">    <span class="attr">category</span>: <span class="string">'framework'</span>,</div><div class="line">    <span class="attr">language</span>: <span class="string">'Node.js'</span>,</div><div class="line">  &#125;;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">exports.page = <span class="function"><span class="keyword">function</span>*(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.body = <span class="string">'&lt;html&gt;&lt;h1&gt;Hello&lt;/h1&gt;&lt;/html&gt;'</span>;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>由于 node 的流式特性，我们还有很多场景需要通过 stream 返回响应，例如返回一个大文件，代理服务器直接返回上游的内容，框架也支持直接将 body 设置成一个 stream，并会同时处理好这个 stream 上的错误事件。</p>
<p><figure class="highlight js"><table><tr><td class="code"><pre><div class="line">exports.proxy = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">const</span> result = <span class="keyword">yield</span> <span class="keyword">this</span>.curl(url, &#123;</div><div class="line">    <span class="attr">streaming</span>: <span class="literal">true</span>,</div><div class="line">  &#125;);</div><div class="line">  <span class="keyword">this</span>.set(result.header);</div><div class="line">  <span class="comment">// result.res 是一个 stream</span></div><div class="line">  <span class="keyword">this</span>.body = result.res;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h4 id="渲染模板"><a class="markdown-anchor" href="#渲染模板">#</a> 渲染模板</h4>
<p>通常来说，我们不会手写 html 页面，而是会通过模板引擎进行生成。
egg 自身没有集成任何一个模板引擎，但是约定了 <a href="../advanced/view-plugin.html">view 插件的规范</a>，通过接入的模板引擎，可以直接使用 <code>this.render(template)</code> 来渲染模板生成 html。
具体示例可以查看 <a href="../core/view.html">模板渲染</a>。</p>
<h4 id="jsonp"><a class="markdown-anchor" href="#jsonp">#</a> JSONP</h4>
<p>有时我们需要给非本域的页面提供接口服务，又由于一些历史原因无法通过 <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS" target="_blank" rel="external">CORS</a> 实现，可以通过 <a href="https://en.wikipedia.org/wiki/JSONP" target="_blank" rel="external">JSONP</a> 来进行响应。</p>
<p>由于 JSONP 如果使用不当会导致非常多的安全问题，所以框架中提供了一个便捷设置 JSONP body 的方式，并封装了 <a href="../core/security.html#jsonp-xss">JSONP 相关的安全防范</a>。</p>
<ul>
<li>通过 <code>context.jsonp=</code> 来设置支持 JSONP 格式的响应。</li>
</ul>
<p><figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="comment">// app/controller/api.js</span></div><div class="line">exports.show = <span class="function"><span class="keyword">function</span>*(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.jsonp = &#123;</div><div class="line">    <span class="attr">name</span>: <span class="string">'egg'</span>,</div><div class="line">    <span class="attr">category</span>: <span class="string">'framework'</span>,</div><div class="line">    <span class="attr">language</span>: <span class="string">'Node.js'</span>,</div><div class="line">  &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>用户请求对应的 URL 访问到这个 controller 的时候，如果 query 中有 <code>_callback=fn</code> 参数，将会返回 JSONP 格式的数据，否则返回 JSON 格式的数据。</p>
<h5 id="jsonp-配置"><a class="markdown-anchor" href="#jsonp-配置">#</a> JSONP 配置</h5>
<p>框架默认通过 query 中的 <code>_callback</code> 参数作为识别是否返回 JSONP 格式数据的依据，并且 <code>_callback</code> 中设置的方法名长度最多只允许 50 个字符。应用可以在 <code>config/config.default.js</code> 覆盖默认的配置：</p>
<p><figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="comment">// config/config.default.js</span></div><div class="line"><span class="built_in">module</span>.exports = &#123;</div><div class="line">  <span class="attr">callback</span>: <span class="string">'callback'</span>, <span class="comment">// 识别 query 中的 `callback` 参数</span></div><div class="line">  limit: <span class="number">100</span>, <span class="comment">// 函数名最长为 100 个字符</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="设置-header"><a class="markdown-anchor" href="#设置-header">#</a> 设置 header</h3>
<p>我们通过状态码标识请求成功与否、状态如何，在 body 中设置响应的内容。而通过响应的 header，还可以设置一些扩展信息。</p>
<p>通过 <code>context.set(key, value)</code> 方法可以设置一个响应头，<code>context.set(headers)</code> 设置多个 header。</p>
<p><figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="comment">// app/controller/api.js</span></div><div class="line">exports.show = <span class="function"><span class="keyword">function</span>*(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">const</span> start = <span class="built_in">Date</span>.now();</div><div class="line">  <span class="keyword">this</span>.body = <span class="keyword">yield</span> <span class="keyword">this</span>.service.post.get();</div><div class="line">  <span class="keyword">const</span> used = <span class="built_in">Date</span>.now() - start;</div><div class="line">  <span class="comment">// 设置一个响应头</span></div><div class="line">  <span class="keyword">this</span>.set(<span class="string">'show-response-time'</span>, userd.toString());</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>

  </article>
  <aside id="mobileAside" class="toc">
    <a id="mobileTrigger" href="#" class="mobile-trigger">
      <ul>
        <li></li>
        <li></li>
        <li></li>
      </ul>
    </a>
    <div class="mobile-menu">
      <ul><li><a href="/zh-cn/intro/" alt="新手指南">新手指南</a></li><li><a href="https://eggjs.org/badgeboard/" alt="插件">插件</a></li><li><a href="/release/" alt="发布记录">发布记录</a></li></ul>
    </div>
    <dl><dt>新手指南</dt><dd><ul><li><a href="/zh-cn/intro/index.html">什么是 egg</a></li><li><a href="/zh-cn/intro/egg-and-koa.html">egg 和 koa</a></li><li><a href="/zh-cn/intro/quickstart.html">快速入门</a></li></ul></dd><dt>基础功能</dt><dd><ul><li><a href="/zh-cn/basics/env.html">运行环境</a></li><li><a href="/zh-cn/basics/config.html">配置</a></li><li><a href="/zh-cn/basics/middleware.html">中间件</a></li><li><a href="/zh-cn/basics/router.html">Router</a></li><li><a href="/zh-cn/basics/controller.html">Controller</a></li><li><a href="/zh-cn/basics/service.html">Service</a></li><li><a href="/zh-cn/basics/schedule.html">定时任务</a></li><li><a href="/zh-cn/basics/extend.html">框架扩展</a></li><li><a href="/zh-cn/basics/app-start.html">启动自定义</a></li></ul></dd><dt>核心功能</dt><dd><ul><li><a href="/zh-cn/core/development.html">本地开发</a></li><li><a href="/zh-cn/core/security.html">安全</a></li><li><a href="/zh-cn/core/httpclient.html">HttpClient</a></li><li><a href="/zh-cn/core/logger.html">日志</a></li><li><a href="/zh-cn/core/error-handling.html">异常处理</a></li><li><a href="/zh-cn/core/i18n.html">国际化</a></li><li><a href="/zh-cn/core/view.html">模板渲染</a></li><li><a href="/zh-cn/core/unittest.html">单元测试</a></li></ul></dd><dt>教程</dt><dd><ul><li><a href="/zh-cn/tutorials/mysql.html">MySQL</a></li><li><a href="/zh-cn/tutorials/restful.html">RESTful API</a></li></ul></dd><dt>进阶</dt><dd><ul><li><a href="/zh-cn/advanced/loader.html">Loader</a></li><li><a href="/zh-cn/advanced/plugin.html">插件开发</a></li><li><a href="/zh-cn/advanced/framework.html">框架开发</a></li><li><a href="/zh-cn/advanced/cluster.html">多进程模型</a></li><li><a href="/zh-cn/advanced/view-plugin.html">模板插件开发规范</a></li></ul></dd><dt>社区</dt><dd><ul><li><a href="/zh-cn/contributing.html">如何贡献</a></li></ul></dd></dl>
  </aside>
</div>

<script>
var mobileTrigger = document.getElementById('mobileTrigger');
var mobileAside = document.getElementById('mobileAside');
mobileTrigger.onclick = function(e) {
  if (mobileAside.className.indexOf('mobile-show') === -1) {
    mobileAside.className += ' mobile-show';
  } else {
    mobileAside.className = 'toc';
  }
};
</script>

    <div class="footer">
  <footer>
    <ul><li><a href="/zh-cn/intro/" alt="新手指南">新手指南</a></li><li><a href="https://eggjs.org/badgeboard/" alt="插件">插件</a></li><li><a href="/release/" alt="发布记录">发布记录</a></li></ul>
    <div class="license">Released under the MIT License <a href="https://github.com/eggjs"><img src="/images/github.svg"/></a></div>
  </footer>
</div>

  </div>
</body>
</html>
